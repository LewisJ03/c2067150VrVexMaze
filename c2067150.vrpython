{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n\ndef check(cordArr,direction):\n    while cordArr[9][16]!=\" \" or cordArr[9][16]!=\".\": #end point in grid\n\n        distSearch=[]#creates array for distance to each object\n        directArr=[\"L\",\"R\",\"F\",\"B\"]#left, right, front,back\n        cordLog(cordArr)\n\n    #below checks each direction for closest object\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        distSearch.append(front_distance.get_distance(MM))\n        drivetrain.turn_for(RIGHT,180,DEGREES)\n        distSearch.append(front_distance.get_distance(MM))\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        distSearch.append(front_distance.get_distance(MM))\n\n        for x in range(len(distSearch)-1):\n            if distSearch[x]>distSearch[x+1]:\n            \n                temp=distSearch[x]\n                distSearch[x]=distSearch[x+1]\n                distSearch[x+1]=temp#sorts directions by shortest distance\n\n                temp=directArr[x]#orders direction chars\n                directArr[x]=directArr[x+1]\n                directArr[x+1]=temp\n\n        for y in range(len(distSearch)):#clears any direction that is close to wall/object\n            if distSearch[0]<100:\n                distSearch.pop(0)\n                directArr.pop(0)\n            else:\n                break\n                \n        tempDir=direction#needs to be temp as only test\n\n        if directArr[0]==\"L\":#sets temporary headings for testing direction priority\n            tempDir-=90\n            if tempDir<0:\n                tempDir=270\n        elif directArr[0]==\"R\":\n            tempDir+=90\n            if tempDir>270:\n                tempDir=0\n        else:\n            if tempDir<180:\n                tempDir+=180\n            else:\n                tempDir=(tempDir+180)-360\n        priority(tempDir,cordArr,directArr,direction)\n        \n    #turns to left and sets heading\n        if directArr[0]==\"L\":\n            drivetrain.turn_for(LEFT,90,DEGREES)\n            direction-=90\n            if direction<0:\n                direction=270\n    \n    #turns to right and sets heading\n        elif directArr[0]==\"R\":\n            drivetrain.turn_for(RIGHT,90,DEGREES)\n            direction+=90\n            if direction>270:\n                direction=0\n\n        elif directArr[0]==\"F\":\n            print()#failsafe for moving forward\n    \n    #makes robot turn back on itself if trapped in dead end\n        else:\n            drivetrain.turn_for(RIGHT,180,DEGREES)\n            if direction<180:\n                direction+=180\n            else:\n                direction=(direction+180)-360\n            check(cordArr,direction)\n        drive(directArr,cordArr,direction)\n\ndef drive(directArr,cordArr,direction):\n    for x in range(20):#loops for 20 before checking Left/Right, 10 causes getting stuck\n        degreeCorrect()\n        drivetrain.drive_for(FORWARD,10,MM)#moves in increments of 10 to stop collisions\n\n        if front_distance.get_distance(MM)<=50:\n            break#stops itself from driving into wall\n        \n        elif left_bumper.pressed():#repositions if bumper pressed\n            lBumper()\n\n        elif right_bumper.pressed():\n            rBumper()\n\n        if down_eye.detect(RED):\n          home(cordArr,direction)#win condition\n          break\n\ndef degreeCorrect():#prevents diagonal heading after collisions\n    compass=location.position_angle(DEGREES)\n    if compass<45 or compass>315:\n        drivetrain.set_rotation(0, DEGREES)\n    elif compass<135 or compass>=45:\n        drivetrain.set_rotation(90, DEGREES)\n    elif compass<225 or compass>=135:\n        drivetrain.set_rotation(180, DEGREES)\n    else:\n        drivetrain.set_rotation(270, DEGREES)\n\n\ndef home(cordArr,direction):\n    rows,cols=(18,18)\n    for x in range(rows):\n        for y in range(cols):\n            try:\n                if(cordArr[x-1][y]==\" \" and cordArr[x+1][y]==\" \") or (cordArr[x-1][y]==\" \" and cordArr[x+2][y]==\" \"):\n                    cordArr[x][y]==\" \"#needed as map sometimes skips one or two points\n            except:\n                print()\n            try:\n                if(cordArr[x][y-1]==\" \" and cordArr[x][y+1]==\" \") or (cordArr[x][y-1]==\" \" and cordArr[x][y2]==\" \"):\n                    cordArr[x][y]==\" \"\n            except:\n                print()\n\n    brain.new_line()\n    for x in range(rows):\n        for y in range(cols):\n            brain.print(cordArr[y][x])#prints out board with know paths\n        brain.new_line()\n\n    brain.print(\"Key:'X'=not explored:' '=travered once:'.'=traversed twice/dead end\")\n\n    #code to restart moving towards starting location\n    drivetrain.turn_for(RIGHT, 180, DEGREES)\n    if direction<180:\n        direction+=180\n    else:\n        direction=(direction+180)-360\n            \n    for i in range(rows):\n        for j in range(cols):\n            cordArr[i][j]='X'\n    #will be able to move the same amount as drive because it has just been there\n    for z in range(20):\n        degreeCorrect()\n        drivetrain.drive_for(FORWARD,10,MM)\n        check(cordArr,direction)\n\ndef init():#initialises 2d array to track movement\n    direction=location.position_angle(DEGREES)#sets the direction facing for path manipulation \n    cordArr=[]\n    rows,cols=18,18\n    for x in range(rows):\n        col=[]\n        for y in range(cols):\n            col.append(\"X\")\n        cordArr.append(col)\n        #also add for tracking correct\n    check(cordArr,direction)\n\ndef cordLog(cordArr):\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)-1#rounds to int, +9 to make out of 18,-1 to fit array\n    arrY=(int(round(cordY/100,0))+9)-1#makes positive but rotates map\n    if cordArr[arrX][arrY]==\"X\":\n        cordArr[arrX][arrY]=\" \"#once taken\n    elif cordArr[arrX][arrY]==\" \":\n        cordArr[arrX][arrY]=\".\"#taken twice do not repeat\n\ndef lBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if left_bumper.pressed():\n        lBumper()#loops moving to right until left bumper is not being pressed\n    degreeCorrect()\n\ndef rBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if right_bumper.pressed():\n        rBumper()#loops moving left to fit through gaps\n    degreeCorrect()\n\ndef priority(tempDir,cordArr,directArr,direction):\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)-1#X&Y in relation to plotting graph\n    arrY=(int(round(cordY/100,0))+9)-1\n    visitCheck=\"0\"#needs to setup outside\n    testCheck=0\n    temp2=direction\n    wallCheck=front_distance.get_distance(MM)\n\n    try:\n        if tempDir==0:\n            visitCheck=cordArr[arrX][arrY+1]#pulls what heading causes next block to be\n            testCheck=cordArr[arrX][arrY+2]\n        elif tempDir==90:\n            visitCheck=cordArr[arrX+1][arrY]\n            testCheck=cordArr[arrX+2][arrY]\n        elif tempDir==180:\n            visitCheck=cordArr[arrX][arrY-1]\n            testCheck=cordArr[arrX][arrY-1]\n        elif tempDir==270:\n            visitCheck=cordArr[arrX-1][arrY]\n            testCheck=cordArr[arrX-2][arrY]\n    except:#failsafe for if tries getting out of bounds, shouldnt happen anymore\n        visitCheck=cordArr[arrX][arrY]\n        testCheck=cordArr[arrX][arrY]\n    \n    if visitCheck==\".\":\n        directArr.pop(0)#removes paths that have already been traversed\n    \n    elif visitCheck==\" \":\n        for x in range(len(directArr)-1):\n\n            if directArr[x+1]==\"L\":\n                temp2-=90\n                if temp2<0:\n                    temp2=270\n            elif directArr[x+1]==\"R\":\n                temp2+=90\n                if temp2>270:\n                    temp2=0\n            try:\n                if temp2==0:\n                    visitCheck2=cordArr[arrX][arrY+1]\n                elif temp2==90:\n                    visitCheck2=cordArr[arrX+1][arrY]\n                elif temp2==180:\n                    visitCheck2=cordArr[arrX][arrY-1]\n                elif temp2==270:\n                    visitCheck2=cordArr[arrX-1][arrY]\n            except:\n                visitCheck2=cordArr[arrX][arrY]\n\n            if visitCheck2=='X' or testCheck=='X':#this is the line\n                #brain.print(directArr[0])\n                temp=directArr[x]\n                directArr[x]=directArr[x+1]\n                directArr[x+1]=temp\n                #break#move directions to above for work as needs to know direction going not gone\n            if directArr[0]==\"B\":\n                directArr.pop(0)\n\nvr_thread(init)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}