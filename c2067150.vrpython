{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n\ndef check(cordArr,direction):\n\n    distSearch=[]#creates array for distance to each object\n    directArr=[\"L\",\"R\",\"F\",\"B\"]#left, right, front,back\n    cordLog(cordArr)\n\n    #below checks each direction for closest object\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n    drivetrain.turn_for(RIGHT,180,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n\n    for x in range(len(distSearch)-1):\n        if distSearch[x]>distSearch[x+1]:\n            \n            temp=distSearch[x]\n            distSearch[x]=distSearch[x+1]\n            distSearch[x+1]=temp#sorts directions by shortest distance\n\n            temp=directArr[x]#orders direction chars\n            directArr[x]=directArr[x+1]\n            directArr[x+1]=temp\n\n    for y in range(len(distSearch)):#clears any direction that is close to wall/object\n        if distSearch[0]<100:\n            distSearch.pop(0)\n            directArr.pop(0)\n        else:\n            break\n#######################################################################\n    tempDir=direction#needs to be temp as only test\n\n    if directArr[0]==\"L\":#sets temporary headings for testing direction priority\n        tempDir-=90\n        if tempDir<0:\n            tempDir=270\n        priority(tempDir,cordArr,directArr)\n    elif directArr[0]==\"R\":\n        tempDir+=90\n        if tempDir>270:\n            tempDir=0\n        priority(tempDir,cordArr,directArr)\n    elif directArr[0]==\"F\":\n        priority(tempDir,cordArr,directArr)\n    else:\n        if tempDir<180:\n            tempDir+=180\n        else:\n            tempDir=(tempDir+180)-360\n        priority(tempDir,cordArr,directArr)\n###############################################################################\n    #turns to left and sets heading\n    if directArr[0]==\"L\":\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        direction-=90\n        if direction<0:\n            direction=270\n    \n    #turns to right and sets heading\n    elif directArr[0]==\"R\":\n        drivetrain.turn_for(RIGHT,90,DEGREES)\n        direction+=90\n        if direction>270:\n            direction=0\n\n    elif directArr[0]==\"F\":\n        print()#failsafe for moving forward\n    \n    #makes robot turn back on itself if trapped in dead end\n    else:\n        drivetrain.turn_for(RIGHT,180,DEGREES)\n        if direction<180:\n            direction+=180\n        else:\n            direction=(direction+180)-360\n        check(cordArr,direction)\n\n    drive(directArr,cordArr,direction)\n\ndef drive(directArr,cordArr,direction):\n    for x in range(20):#loops for 20 before checking Left/Right, 10 causes getting stuck\n        degreeCorrect()\n        drivetrain.drive_for(FORWARD,10,MM)#moves in increments of 10 to stop collisions\n\n        pen.set_pen_width(EXTRA_WIDE)#pen settings for testing\n        pen.set_pen_color(GREEN)\n        pen.move(DOWN)\n\n        if front_distance.get_distance(MM)<=50:\n            break#stops itself from driving into wall\n        \n        elif left_bumper.pressed():#repositions if bumper pressed\n            lBumper()\n\n        elif right_bumper.pressed():\n            rBumper()\n\n        if down_eye.detect(RED):\n          home(cordARR)#win condition\n    \n    check(cordArr,direction)\n\ndef degreeCorrect():#prevents diagonal heading after collisions\n    compass=location.position_angle(DEGREES)\n    if compass<45 or compass>315:\n        drivetrain.set_rotation(0, DEGREES)\n    elif compass<135 or compass>=45:\n        drivetrain.set_rotation(90, DEGREES)\n    elif compass<225 or compass>=135:\n        drivetrain.set_rotation(180, DEGREES)\n    else:\n        drivetrain.set_rotation(270, DEGREES)\n\n\ndef home(cordArr):\n    #return home here\n    rows,cols=(18,18)\n    for i in range(rows):\n        brain.print(cordsArr[17][i])#needs to do last layer first due to plotting\n    brain.new_line()\n    for x in range(rows):\n        for y in range(cols-1):\n            brain.print(cordArr[x][y])#prints out board with know paths\n        brain.new_line()\n\ndef init():#initialises 2d array to track movement\n    direction=location.position_angle(DEGREES)#sets the direction facing for path manipulation \n    cordArr=[]\n    rows,cols=18,18\n    for x in range(rows):\n        col=[]\n        for y in range(cols):\n            col.append(\"X\")\n        cordArr.append(col)\n        #also add for tracking correct\n    check(cordArr,direction)\n\ndef cordLog(cordArr):\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)-1#rounds to int, +9 to make out of 18,-1 to fit array\n    arrY=(int(round(cordY/100,0))+9)-1#makes positive but rotates map\n    if cordArr[arrX][arrY]==\"X\":\n        cordArr[arrX][arrY]=\"  \"#once taken\n    elif cordArr[arrX][arrY]==\"  \":\n\n        cordArr[arrX][arrY]=\"..\"#taken twice do not repeat\n\ndef lBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if left_bumper.pressed():\n        lBumper()#loops moving to right until left bumper is not being pressed\n    degreeCorrect()\n\ndef rBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if right_bumper.pressed():\n        rBumper()#loops moving left to fit through gaps\n    degreeCorrect()\n\ndef priority(tempDir,cordArr,directArr):\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)-1#X&Y in relation to plotting graph\n    arrY=(int(round(cordY/100,0))+9)-1\n    visitCheck=\"0\"#needs to setup outside\n    try:\n        if tempDir==0:\n            visitCheck=cordArr[arrX][arrY+1]#pulls what heading causes next block to be\n        elif tempDir==90:\n            visitCheck=cordArr[arrX+1][arrY]\n        elif tempDir==180:\n            visitCheck=cordArr[arrX][arrY-1]\n        elif tempDir==270:\n            visitCheck=cordArr[arrX-1][arrY]\n    except:#failsafe for if tries getting out of bounds, shouldnt happen anymore\n        if tempDir==0:\n            visitCheck=cordArr[arrX][arrY]\n        elif tempDir==90:\n            visitCheck=cordArr[arrX][arrY]\n        elif tempDir==180:\n            visitCheck=cordArr[arrX][arrY]\n        elif tempDir==270:\n            visitCheck=cordArr[arrX][arrY]\n    \n    if visitCheck==\"..\":\n        directArr.pop(0)#removes paths that have already been traversed\n\n    elif visitCheck==\"  \":\n        for x in range(len(directArr)):\n            brain.print(visitCheck)\n            if visitCheck=='X':#this is the line\n                temp=directArr[x]\n                directArr[x]=directArr[0]\n                directArr[0]=temp\n                brain.print(directArr[0])\n                break#move directions to above for work as needs to know direction going not gone\n\nvr_thread(init)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}