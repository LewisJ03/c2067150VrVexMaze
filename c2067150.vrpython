{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\n\ndef check(cordArr,direction):\n\n    distSearch=[]#creates array for distance to each object\n    directArr=[\"L\",\"R\",\"F\",\"B\"]\n\n    cordLog(cordArr)\n    brain.print(cordArr)\n\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n    drivetrain.turn_for(RIGHT,180,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    distSearch.append(front_distance.get_distance(MM))\n\n    for x in range(len(distSearch)-1):\n        if distSearch[x]>distSearch[x+1]:\n            \n            temp=distSearch[x]\n            distSearch[x]=distSearch[x+1]\n            distSearch[x+1]=temp#sorts directions by shortest distance\n\n            temp=directArr[x]#orders direction char\n            directArr[x]=directArr[x+1]\n            directArr[x+1]=temp\n\n    for y in range(len(distSearch)):#clears any direction that is not accessable\n        if distSearch[0]<100:\n            distSearch.pop(0)\n            directArr.pop(0)\n        else:\n            break\n\n    #pull current cord map\n    #if left, right, front\n    #if '..' pop from array\n    #if '  ' check next in array for 'X' in len(arr)\n    #if no 'X' take '  ' else take first 'X'\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)\n    arrY=(int(round(cordY/100,0))+9)\n    \n\n\n\n    if directArr[0]==\"L\":\n        drivetrain.turn_for(LEFT,90,DEGREES)\n        direction-=90\n        if direction<0:\n            direction=270\n        drive(directArr,cordArr,direction)\n    elif directArr[0]==\"R\":\n        drivetrain.turn_for(RIGHT,90,DEGREES)\n        direction+=90\n        if direction>270:\n            direction=0\n        drive(directArr,cordArr,direction)\n    elif directArr[0]==\"F\":\n        drive(directArr,cordArr,direction)\n    else:\n        drivetrain.turn_for(RIGHT,180,DEGREES)\n        if direction<180:\n            direction+=180\n        else:\n            direction=(direction+180)-360\n\n    check(cordArr,direction)\n\ndef drive(directArr,cordArr,direction):\n    for x in range(20):\n        degreeCorrect()\n        drivetrain.drive_for(FORWARD,10,MM)#moves in increments of 10,most effective?\n\n        pen.set_pen_width(EXTRA_WIDE)#pen settings for testing\n        pen.set_pen_color(GREEN)\n        pen.move(DOWN)\n\n        if front_distance.get_distance(MM)<=50:\n            break#stops itself from driving into wall\n        \n        elif left_bumper.pressed():#repositions if bumper pressed\n            lBumper()\n\n        elif right_bumper.pressed():\n            rBumper()\n\n        if down_eye.detect(RED):\n          home(cordARR)  \n    \n    check(cordArr,direction)\n\ndef degreeCorrect():#prevents diagonal heading after collisions\n    compass=location.position_angle(DEGREES)\n    if compass<45 or compass>315:\n        drivetrain.set_rotation(0, DEGREES)\n    elif compass<135 or compass>=45:\n        drivetrain.set_rotation(90, DEGREES)\n    elif compass<225 or compass>=135:\n        drivetrain.set_rotation(180, DEGREES)\n    else:\n        drivetrain.set_rotation(270, DEGREES)\n\n\ndef home(cordARR):\n    #return home\n    brain.print(cordARR)\n\ndef init():#initialises 2d array to track movement\n    direction=location.position_angle(DEGREES)#sets the direction facing for path manipulation \n    cordArr=[]\n    rows,cols=18,18\n    for x in range(rows):\n        col=[]\n        for y in range(cols):\n            col.append(\"X\")\n        cordArr.append(col)\n        #also add for tracking correct\n    check(cordArr,direction)\n\ndef cordLog(cordArr):\n    cordX=location.position(X, MM)#pulls X&Y\n    cordY=location.position(Y, MM)\n    arrX=(int(round(cordX/100,0))+9)-1#rounds to int, +9 to make out of 18,-1 to fit array\n    arrY=(int(round(cordY/100,0))+9)-1#makes positive but rotates map\n    if cordArr[arrX][arrY]==\"X\":\n        cordArr[arrX][arrY]=\"  \"#once taken\n    elif cordArr[arrX][arrY]==\"  \":\n\n        cordArr[arrX][arrY]=\"..\"#taken twice do not repeat\n\ndef lBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if left_bumper.pressed():\n        lBumper()\n    degreeCorrect()\n\ndef rBumper():\n    drivetrain.drive_for(REVERSE,20,MM)\n    drivetrain.turn_for(RIGHT,90,DEGREES)\n    drivetrain.drive_for(REVERSE,10,MM)\n    drivetrain.turn_for(LEFT,90,DEGREES)\n    drivetrain.drive_for(FORWARD,20,MM)\n    if right_bumper.pressed():\n        rBumper()\n    degreeCorrect()\n\nvr_thread(init)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}